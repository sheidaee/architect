angular.module('builder.styling')
    .factory('css', ['$rootScope', function($rootScope) {

        var css = {

            rules: {},

            sheet: null,

            /**
             * Load given css into iframe.
             *
             * @param  string cssString
             * @return {void
		 */
            loadCss: function(cssString) {

                var editorCss = $rootScope.frameHead.find('#editor-css');

                //clear current css
                editorCss.html('');

                //load given css
                editorCss.append("\n"+cssString);
            },

            /**
             * Compile custom user css and css generated by the
             * builder itself into a single formatted string.
             *
             * @return string
             */
            compile: function() {
                var css = '',
                    obj = $.extend(true, {}, this.rules);

                for (var selector in obj) {
                    css += selector + ' {\n'
                    for (var rule in obj[selector]) {
                        if (rule.indexOf('_') !== 0) {
                            css += '    ' + rule + ': ' + obj[selector][rule] + ";\n";
                        }
                    }

                    css += "}\n\n";
                }

                var compiled = css+$rootScope.customCss.html().replace(/\/\*!(.|\n)+?\*\//, '').trim();

                return compiled;
            },

            getValueFor: function(selector, style) {
                var ruleStack = this.rules[selector];

                if (ruleStack && ruleStack[style]) {
                    return ruleStack[style];
                }

                return $rootScope.selected.getStyle(style);
            },

            /**
             * Format given selector to a string.
             *
             * @param  mixed selector
             * @return string
             */
            formatSelector: function(selector) {
                var hadDynamicClasses = false;

                if ( ! selector) {
                    selector = $rootScope.selected.selector;
                }

                //if we're passed an array of element parents as selector
                //we'll need to parse that to a string first
                if (angular.isArray(selector)) {
                    var mapped = $.map(selector, function(obj) {

                        //if it's a string just return it
                        if (angular.isString(obj)) {
                            return obj;

                            //if not we'll need to use node class, id or name
                        } else {

                            //if node has an id return that
                            if (obj.node.id) {
                                return '#'+obj.node.id;

                                //next try to get a class
                            } else if (obj.node.className) {
                                var c = obj.node.className.split(' ');

                                //return the longest class as that one is most likely to be unique
                                return '.'+c.reduce(function (a, b) { return a.length > b.length ? a : b; });

                                //lastly use node name if nothing else is available
                            } else {
                                return obj.node.nodeName.toLowerCase();
                            }
                        }
                    });

                    return mapped.join(' > ');
                }

                return selector;
            },

            add: function(selector, style, value, oldValue, noEvent) {

                if ( ! this.sheet) {
                    this.sheet = $('<style id="inspector-css"></style').appendTo($rootScope.frameHead)[0].sheet;
                }

                if (selector) {
                    selector = this.formatSelector(selector);
                } else {
                    selector = $rootScope.selected.selector;
                }

                //if style is an object then wel'll need to loop
                //trough it and call this method for each property
                if (angular.isObject(style)) {
                    for (var prop in style) {
                        this.add(selector, prop, style[prop]);
                    }
                }

                if (angular.isObject(value)) {
                    value = this.objectToString(value);
                }

                //cache the css rules object for this selector
                var ruleStack = this.rules[selector];

                if (ruleStack) {
                    //add new value to cached cssRule object, this
                    //will instantly reflect new css style in the DOM
                    ruleStack._cssObject.style[style.toCamelCase()] = value;

                    //store new value in our custom css object
                    ruleStack[style.toDashedCase()] = value;
                } else {
                    //create and cache css rules object for this selector
                    var ruleStack = this.rules[selector] = {};

                    //add new style to our custom css object
                    ruleStack[style.toDashedCase()] = value;

                    //insert new style as a rule into iframe styleSheets object
                    //so it's reflected in the DOM instantly
                    this.sheet.insertRule(selector+'{'+style+':'+value+';}', 0);

                    //cache the cssRule object so we can modify it later instead
                    //of creating a ton of new rules and eating up the memory
                    ruleStack._cssObject = this.sheet.cssRules[0];
                }

                if ( ! noEvent) {
                    $rootScope.$broadcast('builder.css.changed');
                }
            },
        };

        return css;
    }])